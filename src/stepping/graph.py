from __future__ import annotations

import re
from collections import defaultdict
from dataclasses import dataclass
from enum import Enum
from typing import Any, Callable, Generic, TypeVar, overload

from stepping.types import strip_annotated

# fmt: off
T = TypeVar("T")
U = TypeVar("U")
V = TypeVar("V")
X = TypeVar("X")
Y = TypeVar("Y")
Z = TypeVar("Z")
T1 = TypeVar("T1")
T2 = TypeVar("T2")
T3 = TypeVar("T3")
T4 = TypeVar("T4")
U1 = TypeVar("U1")
U2 = TypeVar("U2")
U3 = TypeVar("U3")
X1 = TypeVar("X1")
X2 = TypeVar("X2")
X3 = TypeVar("X3")
Y1 = TypeVar("Y1")
Y2 = TypeVar("Y2")
Y3 = TypeVar("Y3")
class A1(Generic[T1]): ...
class A2(Generic[T1, T2]): ...
class A3(Generic[T1, T2, T3]): ...
class A4(Generic[T1, T2, T3, T4]): ...
# Maybe in the future, I can use:
# TT = TypeVarTuple("TT")
# class A(Generic[Unpack[TT]]): ...
# fmt: on


class VertexKind(str, Enum):
    DEFAULT = "DEFAULT"
    DELAY = "DELAY"
    IDENTITY = "IDENTITY"
    ADD = "ADD"


@dataclass
class VertexUnary(Generic[T, V]):
    t: type[T]
    v: type[V]
    identifier: str
    f: Callable[[T], V]
    kind: VertexKind = VertexKind.DEFAULT

    def __hash__(self) -> int:
        return hash((self.identifier,))

    @property
    def g(self) -> Graph[A1[T], A1[V]]:
        return Graph(
            vertices=[self],
            input=[(self, 0)],
            internal=set(),
            output=[self],
        )


@dataclass
class VertexBinary(Generic[T, U, V]):
    t: type[T]
    u: type[U]
    v: type[V]
    identifier: str
    f: Callable[[T, U], V]
    kind: VertexKind = VertexKind.DEFAULT

    def __hash__(self) -> int:
        return hash((self.identifier,))

    @property
    def g(self) -> Graph[A2[T, U], A1[V]]:
        return Graph(
            vertices=[self],
            input=[(self, 0), (self, 1)],
            internal=set(),
            output=[self],
        )


Vertex = VertexUnary | VertexBinary
Port = tuple[Vertex, int]


@dataclass
class Graph(Generic[T, V]):
    vertices: list[Vertex]
    input: list[Port]  # in -> a
    internal: set[tuple[Vertex, Port]]  # a -> b
    output: list[Vertex]  # b -> out

    def __post_init__(self) -> None:
        # validate unique vertex identifiers
        vertex_identifiers: dict[str, int] = defaultdict(int)
        for vertex in self.vertices:
            vertex_identifiers[vertex.identifier] += 1
        for identifier, count in vertex_identifiers.items():
            if count != 1:
                raise RuntimeError(
                    f"Saw vertices with duplicate identifier: {identifier}"
                )
        # validate runtime types match
        for start, [end, i] in self.internal:
            start_type = strip_annotated(start.v)
            end_type = strip_annotated(end.t)
            if i == 1:
                assert isinstance(end, VertexBinary)
                end_type = strip_annotated(end.u)
            if start_type != end_type:
                raise RuntimeError(
                    f"start.v: {start_type} doesn't match end.{'u' if i == 1 else 't'}: {end_type}"
                )

    # fmt: off
    @overload # --------- 1 to N from here down --------- #
    def connect(a: Graph[X, A1[U1]],         b: Graph[A1[U1],         Z]) -> Graph[X, Z]: ...
    @overload
    def connect(a: Graph[X, A1[U1]],         b: Graph[A2[U1, U1],     Z]) -> Graph[X, Z]: ...
    @overload
    def connect(a: Graph[X, A1[U1]],         b: Graph[A3[U1, U1, U1], Z]) -> Graph[X, Z]: ...
    @overload  # --------- N to N from here down --------- #
    def connect(a: Graph[X, A2[U1, U2]],     b: Graph[A2[U1, U2],     Z]) -> Graph[X, Z]: ...
    @overload
    def connect(a: Graph[X, A3[U1, U2, U3]], b: Graph[A3[U1, U2, U3], Z]) -> Graph[X, Z]: ...
    # fmt: on
    def connect(a: Graph[Any, Any], b: Graph[Any, Any]) -> Graph[Any, Any]:
        if len(a.output) == 1:
            internal = {(a.output[0], b.input[i]) for i in range(len(b.input))}
        else:
            internal = {(a.output[i], b.input[i]) for i in range(len(a.output))}
        return Graph(
            vertices=a.vertices + b.vertices,
            input=a.input,
            internal=internal | a.internal | b.internal,
            output=b.output,
        )


# generated by python  tests/_graph_types.py
# fmt: off
@overload
def stack(a: Graph[A1[T1], A1[U1]], b: Graph[A1[X1], A1[Y1]]) -> Graph[A2[T1, X1], A2[U1, Y1]]:  ...
@overload
def stack(a: Graph[A1[T1], A1[U1]], b: Graph[A1[X1], A2[Y1, Y2]]) -> Graph[A2[T1, X1], A3[U1, Y1, Y2]]:  ...
@overload
def stack(a: Graph[A1[T1], A1[U1]], b: Graph[A2[X1, X2], A1[Y1]]) -> Graph[A3[T1, X1, X2], A2[U1, Y1]]:  ...
@overload
def stack(a: Graph[A1[T1], A1[U1]], b: Graph[A2[X1, X2], A2[Y1, Y2]]) -> Graph[A3[T1, X1, X2], A3[U1, Y1, Y2]]:  ...
@overload
def stack(a: Graph[A1[T1], A2[U1, U2]], b: Graph[A1[X1], A1[Y1]]) -> Graph[A2[T1, X1], A3[U1, U2, Y1]]:  ...
@overload
def stack(a: Graph[A1[T1], A2[U1, U2]], b: Graph[A1[X1], A2[Y1, Y2]]) -> Graph[A2[T1, X1], A4[U1, U2, Y1, Y2]]:  ...
@overload
def stack(a: Graph[A1[T1], A2[U1, U2]], b: Graph[A2[X1, X2], A1[Y1]]) -> Graph[A3[T1, X1, X2], A3[U1, U2, Y1]]:  ...
@overload
def stack(a: Graph[A1[T1], A2[U1, U2]], b: Graph[A2[X1, X2], A2[Y1, Y2]]) -> Graph[A3[T1, X1, X2], A4[U1, U2, Y1, Y2]]:  ...
@overload
def stack(a: Graph[A2[T1, T2], A1[U1]], b: Graph[A1[X1], A1[Y1]]) -> Graph[A3[T1, T2, X1], A2[U1, Y1]]:  ...
@overload
def stack(a: Graph[A2[T1, T2], A1[U1]], b: Graph[A1[X1], A2[Y1, Y2]]) -> Graph[A3[T1, T2, X1], A3[U1, Y1, Y2]]:  ...
@overload
def stack(a: Graph[A2[T1, T2], A1[U1]], b: Graph[A2[X1, X2], A1[Y1]]) -> Graph[A4[T1, T2, X1, X2], A2[U1, Y1]]:  ...
@overload
def stack(a: Graph[A2[T1, T2], A1[U1]], b: Graph[A2[X1, X2], A2[Y1, Y2]]) -> Graph[A4[T1, T2, X1, X2], A3[U1, Y1, Y2]]:  ...
@overload
def stack(a: Graph[A2[T1, T2], A2[U1, U2]], b: Graph[A1[X1], A1[Y1]]) -> Graph[A3[T1, T2, X1], A3[U1, U2, Y1]]:  ...
@overload
def stack(a: Graph[A2[T1, T2], A2[U1, U2]], b: Graph[A1[X1], A2[Y1, Y2]]) -> Graph[A3[T1, T2, X1], A4[U1, U2, Y1, Y2]]:  ...
@overload
def stack(a: Graph[A2[T1, T2], A2[U1, U2]], b: Graph[A2[X1, X2], A1[Y1]]) -> Graph[A4[T1, T2, X1, X2], A3[U1, U2, Y1]]:  ...
@overload
def stack(a: Graph[A2[T1, T2], A2[U1, U2]], b: Graph[A2[X1, X2], A2[Y1, Y2]]) -> Graph[A4[T1, T2, X1, X2], A4[U1, U2, Y1, Y2]]:  ...
# fmt: on
def stack(a: Graph[Any, Any], b: Graph[Any, Any]) -> Graph[Any, Any]:
    return Graph(
        vertices=a.vertices + b.vertices,
        input=a.input + b.input,
        internal=a.internal | b.internal,
        output=a.output + b.output,
    )


# fmt: off
@overload
def union_inputs(a: Graph[T, A1[U1]],     b: Graph[T, A1[Y1]]) -> Graph[T, A2[U1, Y1]]:      ...
@overload
def union_inputs(a: Graph[T, A2[U1, U2]], b: Graph[T, A1[Y1]]) -> Graph[T, A3[U1, U2, Y1]]:  ...
# fmt: on
def union_inputs(a: Graph[Any, Any], b: Graph[Any, Any]) -> Graph[Any, Any]:
    assert a.input == b.input
    return Graph(
        vertices=list(set(a.vertices + b.vertices)),
        input=a.input,
        internal=a.internal | b.internal,
        output=a.output + b.output,
    )


# fmt: off
@overload
def get_single_vertex(a: Graph[A1[T], A1[V]]) -> VertexUnary[T, V]: ...
@overload
def get_single_vertex(a: Graph[A2[T, U], A1[V]]) -> VertexBinary[T, U, V]: ...
# fmt: on
def get_single_vertex(
    a: Graph[Any, Any]
) -> VertexUnary[Any, Any] | VertexBinary[Any, Any, Any]:
    assert len(a.vertices) == 1
    return a.vertices[0]


def write_png(
    graph: Graph[Any, Any],
    path: str,
    simplify_labels: bool = True,
) -> None:
    import pydot

    g = pydot.Dot(
        graph_type="digraph",
        # rankdir="LR",
        texmode="math",
    )

    def to_color(v: Vertex) -> str:
        if v.identifier.startswith("join"):
            return "coral"
        if v.identifier.startswith("add"):
            return "deepskyblue"
        if v.identifier.startswith("per") or v.identifier.startswith("unper"):
            return "firebrick4"
        if v.identifier.startswith("delay"):
            return "gold"
        if v.identifier.startswith("map"):
            return "beige"
        if v.identifier.startswith("neg"):
            return "cornflowerblue"
        if v.identifier.startswith("partition"):
            return "orange"
        if v.identifier.startswith("reduce"):
            return "silver"
        return "white"

    for vertex in graph.vertices:
        label = vertex.identifier
        if simplify_labels:
            label, *_ = vertex.identifier.split("__")
        g.add_node(
            pydot.Node(
                vertex.identifier,
                fillcolor=to_color(vertex),
                style="filled",
                label=label,
            )
        )

    def munge_type_name(t: type) -> str:
        return re.sub(r"\w+\.", r"", repr(strip_annotated(t)))

    for i, [vertex, _] in enumerate(graph.input):
        g.add_node(pydot.Node(f"input__{i}", fillcolor="red", style="filled"))
        g.add_edge(
            pydot.Edge(
                f"input__{i}", vertex.identifier, label=munge_type_name(vertex.t)
            )
        )
    for i, vertex in enumerate(graph.output):
        g.add_node(pydot.Node(f"output__{i}", fillcolor="red", style="filled"))
        g.add_edge(
            pydot.Edge(
                vertex.identifier, f"output__{i}", label=munge_type_name(vertex.v)
            )
        )
    for start, [end, i] in graph.internal:
        g.add_edge(
            pydot.Edge(
                start.identifier,
                end.identifier,
                label=f"[{i}] " + munge_type_name(start.v),
            )
        )
    g.write_png(path)
