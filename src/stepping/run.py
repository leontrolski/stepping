from __future__ import annotations

from collections import defaultdict
from dataclasses import dataclass
from typing import Any, Callable, Generic, TypeVar, overload

from stepping.graph import (
    A1,
    A2,
    A3,
    A4,
    Graph,
    Vertex,
    VertexBinary,
    VertexKind,
    VertexUnary,
    get_single_vertex,
)
from stepping.operators.linear import identity
from stepping.types import Store, ZSet
from stepping.zset.python import ZSetPython

T = TypeVar("T")
U = TypeVar("U")
V = TypeVar("V")
T1 = TypeVar("T1")
T2 = TypeVar("T2")
T3 = TypeVar("T3")
T4 = TypeVar("T4")
U1 = TypeVar("U1")
U2 = TypeVar("U2")
U3 = TypeVar("U3")
U4 = TypeVar("U4")


# generated by python tests/_graph_types.py
# fmt: off
@overload
def iteration(store: Store, g: Graph[A1[T1], A1[U1]], inputs: tuple[T1]) -> tuple[U1]: ...
@overload
def iteration(store: Store, g: Graph[A1[T1], A2[U1, U2]], inputs: tuple[T1]) -> tuple[U1, U2]: ...
@overload
def iteration(store: Store, g: Graph[A1[T1], A3[U1, U2, U3]], inputs: tuple[T1]) -> tuple[U1, U2, U3]: ...
@overload
def iteration(store: Store, g: Graph[A1[T1], A4[U1, U2, U3, U4]], inputs: tuple[T1]) -> tuple[U1, U2, U3, U4]: ...
@overload
def iteration(store: Store, g: Graph[A2[T1, T2], A1[U1]], inputs: tuple[T1, T2]) -> tuple[U1]: ...
@overload
def iteration(store: Store, g: Graph[A2[T1, T2], A2[U1, U2]], inputs: tuple[T1, T2]) -> tuple[U1, U2]: ...
@overload
def iteration(store: Store, g: Graph[A2[T1, T2], A3[U1, U2, U3]], inputs: tuple[T1, T2]) -> tuple[U1, U2, U3]: ...
@overload
def iteration(store: Store, g: Graph[A2[T1, T2], A4[U1, U2, U3, U4]], inputs: tuple[T1, T2]) -> tuple[U1, U2, U3, U4]: ...
@overload
def iteration(store: Store, g: Graph[A3[T1, T2, T3], A1[U1]], inputs: tuple[T1, T2, T3]) -> tuple[U1]: ...
@overload
def iteration(store: Store, g: Graph[A3[T1, T2, T3], A2[U1, U2]], inputs: tuple[T1, T2, T3]) -> tuple[U1, U2]: ...
@overload
def iteration(store: Store, g: Graph[A3[T1, T2, T3], A3[U1, U2, U3]], inputs: tuple[T1, T2, T3]) -> tuple[U1, U2, U3]: ...
@overload
def iteration(store: Store, g: Graph[A3[T1, T2, T3], A4[U1, U2, U3, U4]], inputs: tuple[T1, T2, T3]) -> tuple[U1, U2, U3, U4]: ...
@overload
def iteration(store: Store, g: Graph[A4[T1, T2, T3, T4], A1[U1]], inputs: tuple[T1, T2, T3, T4]) -> tuple[U1]: ...
@overload
def iteration(store: Store, g: Graph[A4[T1, T2, T3, T4], A2[U1, U2]], inputs: tuple[T1, T2, T3, T4]) -> tuple[U1, U2]: ...
@overload
def iteration(store: Store, g: Graph[A4[T1, T2, T3, T4], A3[U1, U2, U3]], inputs: tuple[T1, T2, T3, T4]) -> tuple[U1, U2, U3]: ...
@overload
def iteration(store: Store, g: Graph[A4[T1, T2, T3, T4], A4[U1, U2, U3, U4]], inputs: tuple[T1, T2, T3, T4]) -> tuple[U1, U2, U3, U4]: ...
# fmt: on
def iteration(
    store: Store,
    g: Graph[Any, Any],
    inputs: tuple[Any, ...],
) -> tuple[Any, ...]:
    """Calculate one interation given some new inputs."""
    passthroughs: list[Vertex] = [
        get_single_vertex(identity(f"input_{i}", ZSetPython[Any])) for i in g.input
    ]
    cache: dict[Vertex, Any] = {
        vertex: value for vertex, value in zip(passthroughs, inputs)
    }

    # sorted by i to ensure insertion order, we assume no gaps
    requires_map: dict[Vertex, list[Vertex]] = defaultdict(list)
    for start, [end, _] in zip(passthroughs, g.input):
        requires_map[end].append(start)
    for start, [end, _] in sorted(g.internal, key=lambda vp: vp[1][1]):
        requires_map[end].append(start)

    def f(vertex: Vertex) -> Any:
        if vertex in cache:
            return cache[vertex]
        if isinstance(vertex, VertexUnary):
            (a,) = requires_map[vertex]
            if vertex.kind is VertexKind.DELAY:
                cache[vertex] = store.get(vertex)
                a_value = f(a)
                store.set(vertex, a_value)
            else:
                a_value = f(a)
                cache[vertex] = vertex.f(a_value)
        elif isinstance(vertex, VertexBinary):
            a, b = requires_map[vertex]
            a_value = f(a)
            b_value = f(b)
            if vertex in cache:  # during an integrate
                return cache[vertex]
            cache[vertex] = vertex.f(a_value, b_value)
        else:
            raise RuntimeError(f"not sure how to handle vertex: {vertex}")
        return cache[vertex]

    values: tuple[ZSet[Any], ...] = ()
    for p in g.output:
        values += (f(p),)

    store.inc()
    return values


@dataclass
class Action(Generic[T, V]):
    insert: Callable[[list[T]], V]
    remove: Callable[[list[T]], V]


# fmt: off
@overload
def actions(store: Store, g: Graph[A1[ZSet[T1]], A1[U1]]) -> tuple[Action[T1, tuple[U1]]]: ...
@overload
def actions(store: Store, g: Graph[A1[ZSet[T1]], A2[U1, U2]]) -> tuple[Action[T1, tuple[U1, U2]]]: ...
@overload
def actions(store: Store, g: Graph[A1[ZSet[T1]], A3[U1, U2, U3]]) -> tuple[Action[T1, tuple[U1, U2, U3]]]: ...
@overload
def actions(store: Store, g: Graph[A1[ZSet[T1]], A4[U1, U2, U3, U4]]) -> tuple[Action[T1, tuple[U1, U2, U3, U4]]]: ...
@overload
def actions(store: Store, g: Graph[A2[ZSet[T1], ZSet[T2]], A1[U1]]) -> tuple[Action[T1, tuple[U1]], Action[T2, tuple[U1]]]: ...
@overload
def actions(store: Store, g: Graph[A2[ZSet[T1], ZSet[T2]], A2[U1, U2]]) -> tuple[Action[T1, tuple[U1, U2]], Action[T2, tuple[U1, U2]]]: ...
@overload
def actions(store: Store, g: Graph[A2[ZSet[T1], ZSet[T2]], A3[U1, U2, U3]]) -> tuple[Action[T1, tuple[U1, U2, U3]], Action[T2, tuple[U1, U2, U3]]]: ...
@overload
def actions(store: Store, g: Graph[A2[ZSet[T1], ZSet[T2]], A4[U1, U2, U3, U4]]) -> tuple[Action[T1, tuple[U1, U2, U3, U4]], Action[T2, tuple[U1, U2, U3, U4]]]: ...
@overload
def actions(store: Store, g: Graph[A3[ZSet[T1], ZSet[T2], ZSet[T3]], A1[U1]]) -> tuple[Action[T1, tuple[U1]], Action[T2, tuple[U1]], Action[T3, tuple[U1]]]: ...
@overload
def actions(store: Store, g: Graph[A3[ZSet[T1], ZSet[T2], ZSet[T3]], A2[U1, U2]]) -> tuple[Action[T1, tuple[U1, U2]], Action[T2, tuple[U1, U2]], Action[T3, tuple[U1, U2]]]: ...
@overload
def actions(store: Store, g: Graph[A3[ZSet[T1], ZSet[T2], ZSet[T3]], A3[U1, U2, U3]]) -> tuple[Action[T1, tuple[U1, U2, U3]], Action[T2, tuple[U1, U2, U3]], Action[T3, tuple[U1, U2, U3]]]: ...
@overload
def actions(store: Store, g: Graph[A3[ZSet[T1], ZSet[T2], ZSet[T3]], A4[U1, U2, U3, U4]]) -> tuple[Action[T1, tuple[U1, U2, U3, U4]], Action[T2, tuple[U1, U2, U3, U4]], Action[T3, tuple[U1, U2, U3, U4]]]: ...
@overload
def actions(store: Store, g: Graph[A4[ZSet[T1], ZSet[T2], ZSet[T3], ZSet[T4]], A1[U1]]) -> tuple[Action[T1, tuple[U1]], Action[T2, tuple[U1]], Action[T3, tuple[U1]], Action[T4, tuple[U1]]]: ...
@overload
def actions(store: Store, g: Graph[A4[ZSet[T1], ZSet[T2], ZSet[T3], ZSet[T4]], A2[U1, U2]]) -> tuple[Action[T1, tuple[U1, U2]], Action[T2, tuple[U1, U2]], Action[T3, tuple[U1, U2]], Action[T4, tuple[U1, U2]]]: ...
@overload
def actions(store: Store, g: Graph[A4[ZSet[T1], ZSet[T2], ZSet[T3], ZSet[T4]], A3[U1, U2, U3]]) -> tuple[Action[T1, tuple[U1, U2, U3]], Action[T2, tuple[U1, U2, U3]], Action[T3, tuple[U1, U2, U3]], Action[T4, tuple[U1, U2, U3]]]: ...
@overload
def actions(store: Store, g: Graph[A4[ZSet[T1], ZSet[T2], ZSet[T3], ZSet[T4]], A4[U1, U2, U3, U4]]) -> tuple[Action[T1, tuple[U1, U2, U3, U4]], Action[T2, tuple[U1, U2, U3, U4]], Action[T3, tuple[U1, U2, U3, U4]], Action[T4, tuple[U1, U2, U3, U4]]]: ...
# fmt: on
def actions(
    store: Store,
    g: Graph[Any, Any],
) -> Any:  # tuple[Action[Any, tuple[Any, ...]], ...]:
    fs = list[Action[Any, tuple[Any, ...]]]()
    for i, _ in enumerate(g.input):

        def insert(inputs: list[Any], i: int = i) -> tuple[Any]:
            input_zsets = tuple(
                (ZSetPython({n: 1 for n in inputs}) if i == j else ZSetPython[Any]())
                for j, _ in enumerate(g.input)
            )
            return iteration(store, g, input_zsets)  # type: ignore

        def remove(inputs: list[Any], i: int = i) -> tuple[Any]:
            input_zsets = tuple(
                (ZSetPython({n: -1 for n in inputs}) if i == j else ZSetPython[Any]())
                for j, _ in enumerate(g.input)
            )
            return iteration(store, g, input_zsets)  # type: ignore

        fs.append(Action(insert, remove))
    return tuple(fs)
