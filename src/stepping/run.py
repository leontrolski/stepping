from __future__ import annotations

from collections import defaultdict
from dataclasses import dataclass, replace
from typing import Any, Generic, Iterator, TypeVar, assert_never, get_args, overload

from stepping.graph import (
    A1,
    A2,
    A3,
    A4,
    Graph,
    OperatorKind,
    Path,
    Vertex,
    VertexBinary,
    VertexUnary,
    VertexUnaryDelay,
    VertexUnaryIntegrateTilZero,
)
from stepping.types import Store, Time, ZSet
from stepping.zset.python import ZSetPython

T = TypeVar("T")
U = TypeVar("U")
V = TypeVar("V")
V_co = TypeVar("V_co", covariant=True)
T1 = TypeVar("T1")
T2 = TypeVar("T2")
T3 = TypeVar("T3")
T4 = TypeVar("T4")
U1 = TypeVar("U1")
U2 = TypeVar("U2")
U3 = TypeVar("U3")
U4 = TypeVar("U4")


# generated by python scripts/type_gen.py
# fmt: off
@overload
def iteration(store: Store, g: Graph[A1[T1], A1[U1]], inputs: tuple[T1], time: Time = Time()) -> tuple[U1]: ...
@overload
def iteration(store: Store, g: Graph[A1[T1], A2[U1, U2]], inputs: tuple[T1], time: Time = Time()) -> tuple[U1, U2]: ...
@overload
def iteration(store: Store, g: Graph[A1[T1], A3[U1, U2, U3]], inputs: tuple[T1], time: Time = Time()) -> tuple[U1, U2, U3]: ...
@overload
def iteration(store: Store, g: Graph[A1[T1], A4[U1, U2, U3, U4]], inputs: tuple[T1], time: Time = Time()) -> tuple[U1, U2, U3, U4]: ...
@overload
def iteration(store: Store, g: Graph[A2[T1, T2], A1[U1]], inputs: tuple[T1, T2], time: Time = Time()) -> tuple[U1]: ...
@overload
def iteration(store: Store, g: Graph[A2[T1, T2], A2[U1, U2]], inputs: tuple[T1, T2], time: Time = Time()) -> tuple[U1, U2]: ...
@overload
def iteration(store: Store, g: Graph[A2[T1, T2], A3[U1, U2, U3]], inputs: tuple[T1, T2], time: Time = Time()) -> tuple[U1, U2, U3]: ...
@overload
def iteration(store: Store, g: Graph[A2[T1, T2], A4[U1, U2, U3, U4]], inputs: tuple[T1, T2], time: Time = Time()) -> tuple[U1, U2, U3, U4]: ...
@overload
def iteration(store: Store, g: Graph[A3[T1, T2, T3], A1[U1]], inputs: tuple[T1, T2, T3], time: Time = Time()) -> tuple[U1]: ...
@overload
def iteration(store: Store, g: Graph[A3[T1, T2, T3], A2[U1, U2]], inputs: tuple[T1, T2, T3], time: Time = Time()) -> tuple[U1, U2]: ...
@overload
def iteration(store: Store, g: Graph[A3[T1, T2, T3], A3[U1, U2, U3]], inputs: tuple[T1, T2, T3], time: Time = Time()) -> tuple[U1, U2, U3]: ...
@overload
def iteration(store: Store, g: Graph[A3[T1, T2, T3], A4[U1, U2, U3, U4]], inputs: tuple[T1, T2, T3], time: Time = Time()) -> tuple[U1, U2, U3, U4]: ...
@overload
def iteration(store: Store, g: Graph[A4[T1, T2, T3, T4], A1[U1]], inputs: tuple[T1, T2, T3, T4], time: Time = Time()) -> tuple[U1]: ...
@overload
def iteration(store: Store, g: Graph[A4[T1, T2, T3, T4], A2[U1, U2]], inputs: tuple[T1, T2, T3, T4], time: Time = Time()) -> tuple[U1, U2]: ...
@overload
def iteration(store: Store, g: Graph[A4[T1, T2, T3, T4], A3[U1, U2, U3]], inputs: tuple[T1, T2, T3, T4], time: Time = Time()) -> tuple[U1, U2, U3]: ...
@overload
def iteration(store: Store, g: Graph[A4[T1, T2, T3, T4], A4[U1, U2, U3, U4]], inputs: tuple[T1, T2, T3, T4], time: Time = Time()) -> tuple[U1, U2, U3, U4]: ...
# fmt: on
def iteration(
    store: Store,
    g: Graph[Any, Any],
    inputs: tuple[Any, ...],
    time: Time = Time(),
) -> tuple[Any, ...]:
    """Calculate one interation given some new inputs."""
    cache = _make_cache(g, inputs)

    # sorted by i to ensure insertion order, we assume no gaps
    requires_map: dict[Vertex, list[Vertex]] = defaultdict(list)
    for start, [p_end, _] in zip(cache, g.input):
        end = g.vertices[p_end]
        requires_map[end].append(start)
    for p_start, [p_end, _] in sorted(g.internal, key=lambda vp: vp[1][1]):
        start = g.vertices[p_start]
        end = g.vertices[p_end]
        requires_map[end].append(start)

    def f(vertex: Vertex) -> Any:
        if vertex in cache:
            return cache[vertex]

        if isinstance(vertex, VertexUnary):
            (a_vertex,) = requires_map[vertex]
            if isinstance(vertex, VertexUnaryDelay):
                cache[vertex] = store.get(vertex, time)
                a = f(a_vertex)
                store.set(vertex, a, time)
            if isinstance(vertex, VertexUnaryIntegrateTilZero):
                [[first_p, _]] = vertex.graph.input
                (a_vertex,) = requires_map[vertex.graph.vertices[first_p]]
                a = f(a_vertex)
                # Don't flush changes, then flush the changes for all delay vertices
                no_flush = Time(time.input_time, time.frontier, flush_every_set=None)
                (v,) = get_args(vertex.v)
                cache[vertex] = _indefinite_integral(
                    store, vertex.graph, v, a, no_flush
                )
                if time.flush_every_set is True:
                    store.flush(vertex.graph.delay_vertices, time)
            else:
                a = f(a_vertex)
                if vertex in cache:  # during a loop
                    return cache[vertex]
                cache[vertex] = vertex.f(a)
        elif isinstance(vertex, VertexBinary):
            a_vertex, b_vertex = requires_map[vertex]
            a = f(a_vertex)
            b = f(b_vertex)
            if vertex in cache:  # during a loop
                return cache[vertex]
            cache[vertex] = vertex.f(a, b)
        else:
            assert_never(vertex)

        return cache[vertex]

    values: tuple[ZSet[Any], ...] = ()
    for p in g.output:
        values += (f(g.vertices[p]),)
    for p in g.run_no_output:
        f(g.vertices[p])

    store.inc(time)
    return values


def _make_cache(
    g: Graph[Any, Any],
    inputs: tuple[Any, ...],
) -> dict[Vertex, Any]:
    """Calculate one interation given some new inputs."""
    passthroughs: list[Vertex] = [
        VertexUnary(
            ZSetPython[Any],
            ZSetPython[Any],
            OperatorKind.identity,
            Path(("passthrough", str(i))),
            lambda n: n,
        )
        for i, _ in enumerate(g.input)
    ]
    return {vertex: value for vertex, value in zip(passthroughs, inputs)}


def _dirac_function(t: type[T], a: ZSet[T]) -> Iterator[ZSet[T]]:
    """Definition 7.1"""
    yield a
    while True:
        yield ZSetPython[T](t)


def _indefinite_integral(
    store: Store,
    g: Graph[A1[ZSet[T]], A1[ZSet[V]]],
    v: type[V],
    input_value: ZSet[T],
    time: Time,
) -> ZSet[V]:
    """Definition 7.2"""
    out = ZSetPython[V](v)

    for v in _dirac_function(v, input_value):
        (next_value,) = iteration(store, g, (v,), time)
        assert isinstance(next_value, ZSetPython)
        if next_value.empty():
            break
        out += next_value

    return out


@dataclass
class Action(Generic[T, V_co]):
    store: Store
    g: Graph[Any, Any]
    t: type[T]
    i: int

    def insert(self, *inputs: T, time: Time = Time()) -> V_co:
        input_zsets = list[Any]()
        input = ZSetPython[T](self.t, ((n, 1) for n in inputs))
        for j, _ in enumerate(self.g.input):
            input_zsets.append(input if self.i == j else ZSetPython[Any](None))
        return iteration(self.store, self.g, tuple(input_zsets), time=time)  # type: ignore[return-value,arg-type]

    def remove(self, *inputs: T, time: Time = Time()) -> V_co:
        input_zsets = list[Any]()
        input = ZSetPython[T](self.t, ((n, -1) for n in inputs))
        for j, _ in enumerate(self.g.input):
            input_zsets.append(input if self.i == j else ZSetPython[Any](None))
        return iteration(self.store, self.g, tuple(input_zsets), time=time)  # type: ignore[return-value,arg-type]

    def replace(self, old: T, new: T, time: Time = Time()) -> V_co:
        input_zsets = list[Any]()
        input = ZSetPython[T](self.t, ((old, -1), (new, 1)))
        for j, _ in enumerate(self.g.input):
            input_zsets.append(input if self.i == j else ZSetPython[Any](None))
        return iteration(self.store, self.g, tuple(input_zsets), time=time)  # type: ignore[return-value,arg-type]


# fmt: off
@overload
def actions(store: Store, g: Graph[A1[ZSet[T1]], A1[U1]]) -> tuple[Action[T1, tuple[U1]]]: ...
@overload
def actions(store: Store, g: Graph[A1[ZSet[T1]], A2[U1, U2]]) -> tuple[Action[T1, tuple[U1, U2]]]: ...
@overload
def actions(store: Store, g: Graph[A1[ZSet[T1]], A3[U1, U2, U3]]) -> tuple[Action[T1, tuple[U1, U2, U3]]]: ...
@overload
def actions(store: Store, g: Graph[A1[ZSet[T1]], A4[U1, U2, U3, U4]]) -> tuple[Action[T1, tuple[U1, U2, U3, U4]]]: ...
@overload
def actions(store: Store, g: Graph[A2[ZSet[T1], ZSet[T2]], A1[U1]]) -> tuple[Action[T1, tuple[U1]], Action[T2, tuple[U1]]]: ...
@overload
def actions(store: Store, g: Graph[A2[ZSet[T1], ZSet[T2]], A2[U1, U2]]) -> tuple[Action[T1, tuple[U1, U2]], Action[T2, tuple[U1, U2]]]: ...
@overload
def actions(store: Store, g: Graph[A2[ZSet[T1], ZSet[T2]], A3[U1, U2, U3]]) -> tuple[Action[T1, tuple[U1, U2, U3]], Action[T2, tuple[U1, U2, U3]]]: ...
@overload
def actions(store: Store, g: Graph[A2[ZSet[T1], ZSet[T2]], A4[U1, U2, U3, U4]]) -> tuple[Action[T1, tuple[U1, U2, U3, U4]], Action[T2, tuple[U1, U2, U3, U4]]]: ...
@overload
def actions(store: Store, g: Graph[A3[ZSet[T1], ZSet[T2], ZSet[T3]], A1[U1]]) -> tuple[Action[T1, tuple[U1]], Action[T2, tuple[U1]], Action[T3, tuple[U1]]]: ...
@overload
def actions(store: Store, g: Graph[A3[ZSet[T1], ZSet[T2], ZSet[T3]], A2[U1, U2]]) -> tuple[Action[T1, tuple[U1, U2]], Action[T2, tuple[U1, U2]], Action[T3, tuple[U1, U2]]]: ...
@overload
def actions(store: Store, g: Graph[A3[ZSet[T1], ZSet[T2], ZSet[T3]], A3[U1, U2, U3]]) -> tuple[Action[T1, tuple[U1, U2, U3]], Action[T2, tuple[U1, U2, U3]], Action[T3, tuple[U1, U2, U3]]]: ...
@overload
def actions(store: Store, g: Graph[A3[ZSet[T1], ZSet[T2], ZSet[T3]], A4[U1, U2, U3, U4]]) -> tuple[Action[T1, tuple[U1, U2, U3, U4]], Action[T2, tuple[U1, U2, U3, U4]], Action[T3, tuple[U1, U2, U3, U4]]]: ...
@overload
def actions(store: Store, g: Graph[A4[ZSet[T1], ZSet[T2], ZSet[T3], ZSet[T4]], A1[U1]]) -> tuple[Action[T1, tuple[U1]], Action[T2, tuple[U1]], Action[T3, tuple[U1]], Action[T4, tuple[U1]]]: ...
@overload
def actions(store: Store, g: Graph[A4[ZSet[T1], ZSet[T2], ZSet[T3], ZSet[T4]], A2[U1, U2]]) -> tuple[Action[T1, tuple[U1, U2]], Action[T2, tuple[U1, U2]], Action[T3, tuple[U1, U2]], Action[T4, tuple[U1, U2]]]: ...
@overload
def actions(store: Store, g: Graph[A4[ZSet[T1], ZSet[T2], ZSet[T3], ZSet[T4]], A3[U1, U2, U3]]) -> tuple[Action[T1, tuple[U1, U2, U3]], Action[T2, tuple[U1, U2, U3]], Action[T3, tuple[U1, U2, U3]], Action[T4, tuple[U1, U2, U3]]]: ...
@overload
def actions(store: Store, g: Graph[A4[ZSet[T1], ZSet[T2], ZSet[T3], ZSet[T4]], A4[U1, U2, U3, U4]]) -> tuple[Action[T1, tuple[U1, U2, U3, U4]], Action[T2, tuple[U1, U2, U3, U4]], Action[T3, tuple[U1, U2, U3, U4]], Action[T4, tuple[U1, U2, U3, U4]]]: ...
# fmt: on
def actions(
    store: Store,
    g: Graph[Any, Any],
) -> Any:  # tuple[Action[Any, tuple[Any, ...]], ...]:
    fs = list[Action[Any, Any]]()
    for i, [path, _] in enumerate(g.input):
        (t,) = get_args(g.vertices[path].t)
        fs.append(Action(store, g, t, i))
    return tuple(fs)
